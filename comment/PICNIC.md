6.3 PICNIC (하)
===
1. 문제 해결 계획
    1. input 받기: relation[n][n]이란 배열을 만들어서 서로 친구인 지를 저장한다.
    2. 0번째 사람부터 n-1번째 사람까지 짝을 지어준다.(중복하여 세지 않도록 순서 대로 세어야 한다.)
    3. 성공한 짝짓기의 숫자를 센다.
    4. 출력한다.
1. 문제 재구성
    * 문제의 조건: n(n은 짝수 & 2 <= n <= 10 )개의 node가 있고 node 사이에는 m(0 <= m <= n(n-1) /2 )개의 쌍방향 edge가 존재한다.
    * 문제의 목적: n/2개의 edge만을 골라서 edge의 양 끝에 모든 node가 달려 있도록 하는 방법의 수를 구하라.
2. 문제 해결 계획
    1. input 받기: n행 n열의 배열을 만든다. a와 b가 친구이면 friendRelation[a][b]와 friendRelation[b][a]를 true로 하고 그렇지 않으면 모두 false로 한다.
    2. 이미 점유된 자리를 표시할 occupied[n] 배열을 선언하고 false로 초기화한다.
    3. 0번째 행에서 1 - 9 중에서 true이면서 가장 작은 수를 찾는다. 
    4. 0과 3에서 찾은 수에 해당하는 occupied 배열의 원소를 true로 만든다.
    5. occupied가 false인 원소 중에서 가장 작은 수를 찾는다.
    6. 5에서 구한 수와 친구이면서 occupied가 false인 값을 구한다.
    7. 반복하다가 문제 없이 occupied의 값이 모두 true가 되면 +1을 한다.
3. 계획 검증: n이 10이고 m이 45인 극단적인 경우를 생각하자. 45C2로 45 * 44 / 2 = 990개의 경우의 수를 센다. 이 것은 범위 안이다. 테스트 케이스의 경우의 수의 최대값인 50을 곱하더라도 4950이므로 100만이란 수에는 한참 못 미치므로 시간 상의 문제는 없다. <— 오류다 45C5까지 있다. 1,221,759로 그렇게 크지 않은 수 이므로 완전 탐색으로 탐색 가능하다. 그러나 비효율적인 방법으로 보인다. 그래서 다른 방식으로 풀었다.
4. 회고
    * 오랜만에 해서 그런지 코드를 어떻게 짜야할지 몰라서 너무 당황했다. 생각을 제대로 정리하지 못해서 재귀함수의 기저 사례를 제대로 만들지 못해서 여기서 시간을 많이 소모한거 같다. 기저 사례를 확실하게 하는게 만드는 것이 중요한 것 같다.
    * 다른 사람들은 다 반복문으로 풀길레 재귀함수를 이용해서 했더니 다른 사람들보다 조금 더 복잡해져버렸다. 예전에 배운 테크닉인 어떤 상태 이전의 것과 그 이후의 상태의 것을 합치는 것을 이용하여 문제를 풀었다.
    * countMix 함수에서 if else 문의 깊이가 3개까지 내려갔다. 이걸로 인해 코드 가독성이 떨어진다. 이런 부분을 다음 부터는 더 개선해야겠다.(또는 다음에 한 번 더 보면서 고치면 좋겠다.)
    * 만족스러운 점은 그래도 결국에 재귀 함수를 통해 문제를 풀어냈다는 것이다. 반복이 더 적절한 문제긴 했지만 다른 문제를 따라서 풀기 싫어 이렇게 했다. 좀 더 머리를 팍팍 굴려서 좋은 풀이를 만들어야겠다.
    * 풀이를 보면, ret라는 함수에 해당 함수를 계속 더하는 방식을 사용하였다. 이를 통해 코드를 더 깔끔하게 만들었다.
    * firstFree, pairWith 등의 변수명 작성도 훨씬 자연스럽고 이해가 잘 가는 이름으로 보인다.